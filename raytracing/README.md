# Raytracing example

This directory contains a simple ASCII-art raytracing program, with versions
of it written both in Python and SPy.

The goals of the demo are:

  - measure Python vs SPy performance on simple but computationally expensive
    algorithm;

  - check whether LLMs are capable of automatically porting existing Python
    code from Python to SPy;

  - have fun with ASCII art.

ASCII art were chosen because at the moment of writing printing to stdout is
the only I/O supported by SPy.

The demo was tested on 2025-10-09, on branch `main`, commit `2b84e48d`.

![SPy doing raytracing](./raytracing.png)

## The Python version

The Python version was originally created by `claude`. There are three files:

  - `raytracing.py`: the core logic. When executed it prints a single scene to
    the terminal.

  - `demo.py`: shows a simple animation.

  - `bench.py`: renders a scene in a loop *without* displaying it, and output
    some performance numbers.

## The SPy version

The SPy version was also generated by `claude`, but in a very different way. I
asked `claude` to automatically port the Python version to SPy.

This is the prompt which I ran from a fresh session:

```
Look at CLAUDE_spy.md. Look at @raytracer.py and @demo.py
Implement the spy equivalents: let's start with raytracer.spy
```

`claude` was able to port the code without manual intervention. The full
transcript is visible [here](https://antocuni.eu/files/claude-code/spy/spy.2025-10-03%20-%20raytracer.html).

Note that currently the SPy interpreter is *super slow*, because it's written
in Python and runs on top of CPython (thus, double interpretation). Because of
that the SPy version contains special logic to determine the size of the
scene:

```python
from __spy__ import is_compiled

def main() -> None:
    if is_compiled():
        size = get_terminal_size()
        width = size.columns
        height = size.lines
    else:
        width = 20
        height = 5
    ...
```

## Running the code

To run the python version, simply run `python raytracer.py` and `python
demo.py`.

Running the spy version is more interesting. We can run it in interpreter
mode:

```
‚ùØ spy --timeit raytracer.spy
[image]
main(): 3.625 seconds
```

We can also run it in interpreter mode *after* redshifting (this is equivalent
to when we run tests in `[dopppler]` mode):

```
‚ùØ spy --timeit -rx --error-mode=lazy raytracer.spy
[image]
main(): 1.800 seconds
```
`-rx` is the short version of `--redshift --execute`.
This is ~2x faster! It is expected because redshifting partially evaluates a
way a lot of logic which the interpreter must execute at every step. So, the
redshifted AST is "smaller" and "faster".

Note that we had to use `--error-mode=lazy`. This is needed because of a bug
in `@struct` behavior. The current implementation of `_list.spy` assumes it
can always compare two items via `==`, but our `@struct` decorator doesn't
generate an `__eq__` (yet). So, as soon as we try to instantiate a
`List[SomeStruct]`, you get type errors:

```
‚ùØ spy --redshift raytracer.spy
TypeError: mismatched types
   --> /home/antocuni/anaconda/spy/stdlib/_list.spy:178:35
178 |                 if ll.items[i] == value:
    |                                   |___| expected `unsafe::ptr[raytracer::Object]`, got `raytracer::Object`

   --> /home/antocuni/anaconda/spy/spy/vm/object.py:489:1
489 |             def w_eq(vm: 'SPyVM', w_self: T, w_other: T) -> 'W_Bool':
    | |___________________________________________________________________| function defined here

   --> /home/antocuni/anaconda/spy/stdlib/_list.spy:178:20
178 |                 if ll.items[i] == value:
    |                    |__________________| operator::EQ called here

```

This is good! It proves that our typechecking actually works eagerly, as it
happens in all statically typed languages. For the sake of the demo, we can
use `--error-mode=lazy` which turns these errors into `raise TypeError`
statements which will be executed at runtime (but not in our demo because we
never compare two lists).

Finally, we can compile our code with `spy --compile` or `spy -c`:

```
‚ùØ spy -c --error-mode=lazy raytracer.spy
[debug] build/raytracer

‚ùØ ./build/raytracer
[image]
```

Note that by default we get a `debug` build, which contains some extra safety
check around pointers, and it's compiled with `-O0`. We can get a faster
version with `--release`:

```
‚ùØ spy -c --error-mode=lazy --release raytracer.spy
[release] build/raytracer
```


## Benchmarking: SPy interpreter vs compiler

First, let's run `bench.spy` in the interpreter. The interpreter is so slow
that we render only 1 frame in this mode:

```
‚ùØ spy bench.spy
Benchmarking raytracer...
Resolution: 80x30
Frames: 1
Total rays: 2400
[...]
FPS: 0.015238664311837555
Rays per second: 36.572794348410135
```

Now, let's try the redshifted interpreted version:
```

‚ùØ spy -rx --error-mode=lazy bench.spy
Benchmarking raytracer...
Resolution: 80x30
Frames: 1
Total rays: 2400
[...]
FPS: 0.03032845381180751
Rays per second: 72.78828914833801
```

This matches the results above: the redshifted version is already 2x faster.

The compiled versions compute 5000 frames. This is the debug build:
```
‚ùØ spy -c --error-mode=lazy bench.spy
[debug] build/bench

‚ùØ ./build/bench
Benchmarking raytracer...
Resolution: 80x30
Frames: 5000
Total rays: 12000000
[...]
FPS: 1246.52
Time per frame: 0.802233 ms
```

This is ~81800x faster than the `[interp]` version üò±.

The release mode is even more impressive:
```
‚ùØ spy -c --error-mode=lazy --release bench.spy
[release] build/bench

‚ùØ ./build/bench
Benchmarking raytracer...
Resolution: 80x30
Frames: 5000
Total rays: 12000000
[...]
FPS: 17254.1
Time per frame: 0.0579572 ms
```

The release build is 13x faster than the debug build. This is caused by two
factors:

  - `-O3` vs `-O0`

  - `-flto`, which is enabled only for `--release`. LTO (Link Time
    Optimization) makes it possible for gcc to inline and optimize across
    different compilation units. In particular, it can optimize
    `range_iterator.__next__` to produce a "fast" for loop.

# Benchmarking: SPy vs Python vs PyPy

```
‚ùØ python bench.py
Benchmarking raytracer...
Resolution: 80x30
Frames: 100
Total rays: 240,000
[..]
FPS: 85.84
Time per frame: 11.65 ms
```

So, the SPy release build is 201x faster than the Python version! This is the
kind of speedup that we can expect from SPy for numerical intensive code.

It is important to underline that a lot of the merit goes to the optimization
capabilities of `gcc`: but this actually proves that the design decision to
emit C code is a good one, because it gives access "for free" to a very big
and mature set of tools.

Just for fun, let's see what is the speed of PyPy. This is the kind of
workload in which the PyPy tracing JIT should shine. To run that, I manually
adjusted the code to compute 5000 frames and to do 2000 frames of warmup, to
give the JIT time to kick in:

```
‚ùØ pypy bench.py
Benchmarking raytracer...
Resolution: 80x30
Frames: 5000
Total rays: 12,000,000
[...]
FPS: 1811.76
Time per frame: 0.55 ms
```

PyPy gives an impressive 21x speedup compared to CPython. SPy version is still
~10x faster than PyPy though.
